// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Retrieve complete compliance metadata for policy evidence
	// (POST /v1/metadata)
	PostV1Metadata(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// PostV1Metadata operation middleware
func (siw *ServerInterfaceWrapper) PostV1Metadata(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostV1Metadata(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.POST(options.BaseURL+"/v1/metadata", wrapper.PostV1Metadata)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AgAA//8d5pHcARUAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
